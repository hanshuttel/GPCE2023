\documentclass[sigplan,anonymous,review]{acmart}
\input{preamble}

%% \BibTeX command to typeset BibTeX logo in the docs
\AtBeginDocument{%
  \providecommand\BibTeX{{%
    Bib\TeX}}}

%% Rights management information.  This information is sent to you
%% when you complete the rights form.  These commands have SAMPLE
%% values in them; it is your responsibility as an author to replace
%% the commands and values with those provided to you when you
%% complete the rights form.
\setcopyright{acmcopyright}
\copyrightyear{2023}
\acmYear{2023}
\acmDOI{XXXXXXX.XXXXXXX}

\acmConference[GPCE 2023]{Make sure to enter the correct
  conference title from your rights confirmation emai}{July 07--07,
  2023}{Woodstock, NY}

\acmPrice{15.00}
\acmISBN{978-1-4503-XXXX-X/18/06}


%%
%% Submission ID.
%% Use this when submitting an article to a sponsored event. You'll
%% receive a unique submission ID from the organizers
%% of the event, and this ID should be used as the parameter to this command.
%%\acmSubmissionID{123-A56-BU3}

%%
%% For managing citations, it is recommended to use bibliography
%% files in BibTeX format.
%%
%% You can then either use BibTeX with the ACM-Reference-Format style,
%% or BibLaTeX with the acmnumeric or acmauthoryear sytles, that include
%% support for advanced citation of software artefact from the
%% biblatex-software package, also separately available on CTAN.
%%
%% Look at the sample-*-biblatex.tex files for templates showcasing
%% the biblatex styles.
%%

%%
%% The majority of ACM publications use numbered citations and
%% references.  The command \citestyle{authoryear} switches to the
%% "author year" style.
%%
%% If you are preparing content for an event
%% sponsored by ACM SIGGRAPH, you must use the "author year" style of
%% citations and references.
%% Uncommenting
%% the next command will enable that style.
%%\citestyle{acmauthoryear}


%%
%% end of the preamble, start of the body of the document source.
\begin{document}

%%
%% The "title" command has an optional parameter,
%% allowing the author to define a "short title" to be used in page headers.
\title{A type-safe generalized editor calculus (Short Paper)}

%%
%% The "author" command and its associated commands are used to define
%% the authors and their affiliations.
%% Of note is the shared affiliation of the first two authors, and the
%% "authornote" and "authornotemark" commands
%% used to denote shared contribution to the research.

%%\orcid{1234-5678-9012}

%\author{Andreas Tor Mortensen}
%\email{atmo20@student.aau.dk}


%\author{Benjamin Bennetzen}
%\email{bbenne20@student.aau.dk}


%\author{Nikolaj Rossander Kristensen}
%\email{nrkr20@student.aau.dk}

%\author{Peter Buus Steffensen}
%%\authornotemark[1]
%\email{psteff19@student.aau.dk
%}

%\affiliation{%
%  \institution{Department of Computer Science at Aalborg University}
%  \streetaddress{Selma Lagerlöfsvej 300}
%  \city{Aalborg}
%  \country{Denmark}
%  \postcode{9220}
%}

%\author{Hans Huttel}
%\email{hans@cs.aau.dk}
%\affiliation{%
%  \institution{Department of Computer Science at Aalborg University}
%  \streetaddress{Selma Lagerlöfsvej 300}
 % \city{Aalborg}
 % \country{Denmark}
 % \postcode{9220}
%}



%%
%% By default, the full list of authors will be used in the page
%% headers. Often, this list is too long, and will overlap
%% other information printed in the page headers. This command allows
%% the author to define a more concise list
%% of authors' names for this purpose.
\renewcommand{\shortauthors}{AAU Bachelor}

\begin{abstract}
In this paper, we present a generalization of a syntax-directed editor calculus, which can be used to instantiate a specialized syntax-directed editor for any language, given by some abstract syntax. The editor calculus guarantees the absence of syntactical errors while allowing incomplete programs. The generalized editor calculus is then encoded into a simply typed lambda calculus, extended with pairs, booleans, pattern matching and fixed points.
\end{abstract}

%%
%% The code below is generated by the tool at http://dl.acm.org/ccs.cfm.
%% Please copy and paste the code instead of the example below.
%%
\begin{CCSXML}
<ccs2012>
   <concept>
       <concept_id>10011007.10011006.10011050.10011023</concept_id>
       <concept_desc>Software and its engineering~Specialized application languages</concept_desc>
       <concept_significance>500</concept_significance>
       </concept>
   <concept>
       <concept_id>10003752.10010124.10010131</concept_id>
       <concept_desc>Theory of computation~Program semantics</concept_desc>
       <concept_significance>500</concept_significance>
       </concept>
   <concept>
       <concept_id>10003752.10010124.10010131.10010134</concept_id>
       <concept_desc>Theory of computation~Operational semantics</concept_desc>
       <concept_significance>500</concept_significance>
       </concept>
 </ccs2012>
\end{CCSXML}

\ccsdesc[500]{Software and its engineering~Specialized application languages}
\ccsdesc[500]{Theory of computation~Program semantics}
\ccsdesc[500]{Theory of computation~Operational semantics}


%%
%% Keywords. The author(s) should pick words that accurately describe
%% the work being presented. Separate the keywords with commas.
\keywords{Syntax-directed editor, Generalisation, lambda calculus}
%% A "teaser" image appears between the author and affiliation
%% information and the body of the document, and typically spans the
%% page.
%\begin{teaserfigure}
 % \includegraphics[width=\textwidth]{Images/windmill.jpg}
 % \caption{Seattle Mariners at Spring Training, 2010.}
%  \Description{Enjoying the baseball game from the third-base
%  seats. Ichiro Suzuki preparing to bat.}
%  \label{fig:teaser}
%\end{teaserfigure}

%\received{20 February 2007}
%\received[revised]{12 March 2009}
%\received[accepted]{5 June 2009}

%%
%% This command processes the author and affiliation and title
%% information and builds the first part of the formatted document.
\maketitle

\section{Introduction}

Syntax-directed editors aka projectional editors are specialized
editors that allow programmers to create programs directly using the
syntax of the programming language. A prominent early example of an
editor of this kind is that of the Cornell Program Synthesizer by Reps and
Teitelbaum \cite{10.1145/358746.358755}, that was designed with the
PL/I language in mind.

More recent developments introduce models of computation that are
specialized towards this form of editing. The Hazelnut framework by
Omar et al. \cite{hazelnut} and the work by Godiksen et al. and
\cite{type_safe_structure_editor} introduce editor calculi that
describe the syntax and operational semantics of editing commands,
including how such commands can be combined. This line of work has
been tailored specifically towards editing abstract syntax trees from
an applied $\lambda$-calculus.

A major advantage of this approach is that it is typed -- each such editor calculus
is equipped with a type system that guarantees that if an editor term
$E$ is well-typed, then $e$ will produce a well-formed program.

However, existing editor calculi do not account for context-sensitive
aspects of program syntax, and notable not the binding 
mechanisms that are prominenet in abstract syntax.

Moreover, the work so far has been dependent on the syntax of the
programming language that the editor must support. Whenever the
programming language changes, the type safety results for the editor
calculus have had to be proved anew. An example of this is the work by
Andersen et al \cite{10.1145/3587216.3587221} on extending the editor
calculus of \cite{type_safe_structure_editor} with let-declarations.

In later work, Reps and Teitelbaum showed \cite{10.1145/390011.808247}
how one can generalize their original work to build a Synthesizer
Generator that would create a syntax-directed editor for any given
programming language, given a specification of its syntax in the form
of an attribute grammar. Around the same time, Donzeau-Gouge et
al. developed the Mentor programming environment
\cite{10.5555/800054.801990} that involved a command language, Mentol,
and allowed designers to specify language-specific specializations
using a specification language, Metal.

In this paper we propose a generalized editor calculus that deals with
these two issues.

Our calculus deals with binding mechanisms by using notions from
higher-order abstract syntax \cite{hoas}. Moreover, and importantly,
we show how to encode encoded our generalized editor calculus into
versions of the simply-typed lambda calculus extended with pairs,
booleans, pattern matching and fixed-points. These fragments are all
known to have type systems with strong safety guarantees, and in this
way we a general result on type safety that applies to any instance of
our generalized editor calculus.

\section{A Generalized Editor Calculus}\label{sec:general_editor}

We first present a generalization of the syntax-directed editor
calculus by \cite{type_safe_structure_editor}.

\subsection{Representing abstract syntax}

We assume the abstract syntax is given by a set of sorts $\SORT$, an arity-indexed family of operators $\OP$ and a sort-indexed family of variables $\VAR$, such as presented in \cite{harper_foundations}.  

The notion of cursors and holes is central to the idea of an editor
calculus. Whereas the calculus in \cite{type_safe_structure_editor}
only has one cursor and hole term, in the general case we need a
cursor and hole operator for every sort in the abstract syntax.  With
the set of sorts $\SORT$, the extended family of operators $\OP$ and
family of variables $\VAR$ we can then define the sort-indexed family
of abstract binding trees (refered to as "abt") $\ABT{}$ as the
smallest family that satisfies the conditions of $\ABT{}$'s in
\cite{harper_foundations}.

\begin{example}\label{ex:abstract_syntax}
Consider the following simple language of expressions with local declarations.
\begin{align*}
  \text{Sort} && \text{Term} & \text{Operator} & \text{Arity} \\
        s & ::= & \text{let $x = e$ in $s$} & \text{let} & (e, e.s)s \\
        & | & e & \text{exp} & (e)s \\
        e & ::= & e_1 + e_2 & \text{plus} & (e,e)e \\
        & | & n & \text{num}[n] & ()e \\
        & | & x & \text{var}[x] & ()e
\end{align*}
 We can here represent
    \begin{equation*}
        \text{let $x=5$ in let $y=10$ in $x+y$}
    \end{equation*}
    as the abt
    \begin{equation*}
        \text{let}(5;x.\text{let}(10;y.\text{exp}(\text{plus}(x;y))))
    \end{equation*} 
%
    We can extend this language with holes and cursors and get
    %
\begin{align*}
        \text{Sort} && \text{Term} & \text{Operator} & \text{Arity} \\
        s & ::= & [s] & \text{cursor}_s & (s)s \\
        & | & \hole{s} & \text{hole}_s & ()s \\
        e & ::= & [e] & \text{cursor}_e & (e)e \\
        & | & \hole{e} & \text{hole}_e & ()e
 \end{align*}
%
    With this extension the statement
    \begin{equation*}
        \text{let $x=[5]$ in $x+\hole{e}$}
    \end{equation*}
    is represented as the abt
    \begin{equation*}
        \text{let}(\text{cursor}_e(5); x.\text{exp}(\text{plus}(x;\text{hole}_e)))    
    \end{equation*}
\end{example}

\subsubsection{The editor calculus}
Editor expressions $E \in \Edt$, where $\Edt$ is the sort of editor
expressions, describe the possible edit actions. The formation rules
are given below.
%
\begin{align*}
  E & ::= & \pi.E  \mid  \phi => E_1|E_2  \mid  E_1 \ggg E_2  \mid  \text{rec} \ x.E  \mid  x  \mid  \text{nil} \\
    \pi & ::= & \text{child} \ n  \mid  \text{parent}  \mid  \{o\} \\
    \phi & ::= & \neg\phi  \mid  \phi_1 \wedge \phi_2  \mid  \phi_1 \vee \phi_2  \mid  @o  \mid  \Diamond o  \mid  \square o
\end{align*}
%
Evaluation of abt's, which \cite{type_safe_structure_editor} introduces through a $eval$ construct, is not included in our generalized version. This omission is due to evaluation being entirely dependent on the dynamics of the language in focus, and not the static and structural properties the abstract syntax describes. To define the concept of evaluation in a generalized manner, it would be necessary to devise a formal and concise approach for specifying the semantics of operators.

\begin{example}\label{ex:editor_calculus}
    We can define a version of the editor calculus for
    \cref{ex:abstract_syntax} by defining the set of operators $o$ ranges over. In this case we have that
    \begin{equation*}
        o \in \{ \text{let}, \text{exp}, \text{hole}_s, \text{plus}, \text{num}[n], \text{var}[x], \text{hole}_e \}
    \end{equation*}
    We can then write e.g. $(@\text{hole}_e =>
    \{\text{plus}\}.\text{nil}|\text{nil})$. This expression would
    substitute the current tree encapsulated by the cursor with the
    $plus$ operator, if the cursor is at the operator
    $\text{hole}_e$. 
\end{example}

\subsubsection{Cursor contexts}
In editor expressions, we frequently refer to performing actions on, or with, the abt that is currently encapsulated by the cursor. To support this notion we introduce cursor contexts $C$, inspired by the zipper data structure by \cite{huet_zipper}, as a way to locate the cursor in an abt. Central to this idea is the cursor context $\ctxhole$, or context hole, which specifies the subtree within which the cursor must reside, either as the root, or one of the first children.  For the full definition of cursor contexts, we refer to the full version of the paper, or to \cite{type_safe_structure_editor}, as they have a very similar construct.


Although a cursor context accurately specifies the subtree where the cursor must reside, it does not inherently guarantee the presence of only one cursor within that subtree. Therefore, it becomes necessary to introduce the concept of well-formed abt's. Informally, a well-formed abt is simply an abt containing exactly one cursor. This is guarantied when an abt can be interpreted as $C[\dot{a}]$, meaning the context C, where $\ctxhole$ is substituted with a tree $\dot{a}$, where the cursor-operator is either the root $\dot{a}$, or one of the children of the root.


\subsection{Semantics}
In this section we present the transition systems and the general forms of transition rules defining these systems, based on the generalized syntax of the editor calculus previously presented. 

\subsubsection{Editor Expressions} \label{sec:Semantics}

The labelled transition system for editor expressions is defined as
$(\Edt \times \ABT{}, Apc \cup \{\epsilon\},
\Rightarrow)$. Transitions are of the form $\lr{E, a} \ltrans{\alpha}
\lr{E', a'}$ where the editor expression $E \in \Edt$ is closed and
the abt $a \in \ABT{}$ is well-formed. The labels of the transitions,
$\alpha$, are the atomic prefix commands $Apc$ and the silent
transition $\epsilon$. The transition relation $\Rightarrow$ is
defined by the rules shown in
\cref{fig:editor_expression_rules}. These facilitate ways of composing
editor expressions together with conditions, sequential composition
and recursion. The means of traversing and modifying an abt are
provided by the prefixed expression $\pi.E$, which evaluates $\pi$
before continuing with $E$. The conditional expression $\phi =>
E_1|E_2$ reduces to $E_1$ if $\phi$ is satisfied and $E_2$
otherwise. The sequential expression $E_1 \ggg E_2$ evaluates $E_2$
only once $E_1$ has been reduced to $nil$. The recursive expression
$rec \ x.E$ binds the recursion variable $x$ in $E$, which can then be
used to recursively iterate an expression. 

\federeboks{c}{
    \infeshort{Cond-1}
            {a |= \phi}
            {\lr{\phi => E_1 | E_2, C[a]} \ltrans{\epsilon} \lr{E_1, C[a]}}
    \\\\
    \infeshort{Cond-2}
        {a \nvDash \phi}
        {\lr{\phi => E_1 | E_2, C[a]} \ltrans{\epsilon} \lr{E_2, C[a]}}
    \\\\
    \infeshort{Seq}
        {\lr{E_1, a} \ltrans{\alpha} \lr{E_1',a'}}
        {\lr{E_1 \ggg E_2, a} \ltrans{\alpha} \lr{E_1' \ggg E_2,a'}}
    \\\\
    \infeshort{Seq-Trivial}
        {}
        {\lr{\text{nil} \ggg E_2, a} \ltrans{\epsilon} \lr{E_2,a}}    
    \\\\
    \infeshort{Recursion}
        {}
        {\lr{\text{rec } x.E,a} \ltrans{\epsilon} \lr{E[x:=rec \ x.E], a}}
    \\\\
    \infeshort{Context}
        {a \ltrans{\pi} a'}
        {\lr{\pi.E, C[a]} \ltrans{\pi} \lr{E, C[a']}}
}{\caption{Reduction rules for editor expressions}\label{fig:editor_expression_rules}}
.

\subsubsection{Substitution and cursor movement}

The labelled transition system for substitutions and cursor movement
is defined as $(\ABT{}, Apc, \Rightarrow)$. This system describes the
semantics of modifying the well-formed abt $a$ encapsulated by the
cursor, by either substituting it with an operator or moving the
cursor up or down the tree. Transitions are therefore of the form $a
\ltrans{\pi} a'$, where $a, a' \in \ABT{}$ and $\pi \in Apc$. 

For substitution we define the transition rule for every label $\{o\}
\in Apc$, which substitutes the abt currently encapuslated by the
cursor with $o$. The general case of this rule is shown in
\cref{fig:substitution_rules}. The side-condition ensures that we can
only substitute operators of sort $s$ with abt's of sort $s$.

\federeboks{c}{
    \infeshort{Ins}
        {}
        {[\hat{a}]  \ltrans{\{o\}} [o(\Vec{x_1}.\hole{{s_1}}; \dots ; \Vec{x_n}.\hole{{s_n}})]}
        $\begin{array}{l}
         \hat{a}, o \in \ABT{}_s % , \\ \text{ where $s$ is the sort of $o$}
        \end{array}$
}{\caption{General form of reduction rule for substitution}\label{fig:substitution_rules}}

For cursor movement we define two transition rules "child  $i$" and
"parent" for every operator $o$ of arity $(\Vec{s_1}.s_1, \dots,$ $
\Vec{s_n}.s_n)s$ and for every $1 \leq i \leq n$. These rules, shown
in \cref{fig:cursor_movement_rules}, facilitate cursor movement from
the parent operator to child $i$ and from child $i$ back to the parent
operator, respectively.

\federeboks{c}{
    \infeshort{Child-i}
        {}
        {[\hat{o}(\Vec{x_1}.\hat{a}_1; \dots; \Vec{x_n}.\hat{a}_n)] \ltrans{\text{child} \ i}} \\ 
        \quad \quad \quad \quad \quad $o(\Vec{x_1}.\hat{a}_1; \dots; \Vec{x_i}.[a_i]; \dots; \Vec{x_n}.\hat{a}_n)$
    \\\\
    \infeshort{Parent}
        {}
        {o(\Vec{x_1}.\hat{a}_1; \dots; \Vec{x_i}.[\hat{a}_i]; \dots; \Vec{x_n}.\hat{a}_n) \ltrans{\text{parent}}} \\
        \quad \quad \quad \quad \quad $[\hat{o}(\Vec{x_1}.\hat{a}_1; \dots; \Vec{x_n}.\hat{a}_n)]$
}{\caption{General form of reduction rules for cursor movement}\label{fig:cursor_movement_rules}}

\begin{example}\label{ex:substitution_rules}
    We now define the semantics of the editor calculus for our simple language. We do not show the transition rules for editor expressions, since these are equivalent to the ones presented in \cref{fig:editor_expression_rules}. 

    The transition system for cursor movement and substitution is defined with respect to the operators $o$ in our language. Based on the general form of substitution rules shown in \cref{fig:substitution_rules}, we define a specialized rule for substituting the tree encapsulated by the cursor for every operator $o$. A selection of these are shown in \cref{fig:example_substitution_rules}.
    \federeboks{c}{
        \infelong{let}
            {}
            {[\hat{a}]  \ltrans{\{\text{let}\}} [\text{let}(\hole{e};x.\hole{s})]}
            $\begin{array}{c}
             \hat{a} \in \ABT{}_s
            \end{array}$
        \\\\
        \infelong{plus}
            {}
            {[\hat{a}]  \ltrans{\{\text{plus}\}} [\text{plus}(\hole{e};\hole{e})]}
            $\begin{array}{c}
             \hat{a} \in \ABT{}_e 
            \end{array}$
        \\\\
        \infelong{var}
            {}
            {[\hat{a}]  \ltrans{\{\text{var} \ x\}} [x]}
            $\begin{array}{c}
             \hat{a} \in \ABT{}_e
            \end{array}$
    }{\caption{Selected reduction rules for substitution}\label{fig:example_substitution_rules}}
    Notice that in every rule we ensure that the substitution can only be performed if the abt $\hat{a}$ is of the same sort as the operator. For example, given the configuration $\lr{\{let\}.nil, \text{let $x = [\hole{e}]$ in $x+x$}}$ we cannot substitute in a statement, as shown below:
    \begin{center}
    \begin{tabular}{c}
        \inference[(Context)]
            {\inference[(let)]
                {}
                {[\hole{e}]  \ltransn{\{\text{let}\}}}
                $\begin{array}{c}
                    \hole{e} \notin \ABT{}_s
                \end{array}$
            }
            {\lr{\{\text{let}\}.\text{nil}, \text{let $x = [\hole{e}]$ in $x+x$}} \ltransn{\{\text{let}\}}}
    \end{tabular}
    \end{center}
        
    Similarly, using the general form of cursor movement transition rules in \cref{fig:cursor_movement_rules}, we define specialized rules for every argument $i$ of every operator $o$. In \cref{fig:example_cursor_movement_rules} we show the parent and child rules for the let operator specifically. The transition rules for the remaining operators would be defined analogous to these.
    \federeboks{c}{
        \infelong{letc-1}
            {}
            {[\text{let}(a_1; x.a_2)] \ltrans{\text{child} \ 1} \text{let}([a_1]; x.a_2)}
        \\\\
        \infelong{letc-2}
            {}
            {[\text{let}(a_1; x.a_2)] \ltrans{\text{child} \ 2} \text{let}(a_1; x.[a_2])}
        \\\\
        \infelong{letp-1}
            {}
            {\text{let}([a_1]; x.a_2) \ltrans{\text{parent}} [\text{let}(a_1; x.a_2)]}
        \\\\
        \infelong{letp-2}
            {}
            {\text{let}(a_1; x.[a_2]) \ltrans{\text{parent}} [\text{let}(a_1; x.a_2)]}
    }{\caption{Reduction rules for cursor movement on the $let$ operator}\label{fig:example_cursor_movement_rules}}
\end{example}

\subsubsection{Conditions}
Finally, we define the satisfaction relation for conditions $\phi$ in our editor calculus. The propositional connectives are defined as expected in \cref{fig:satisfaction_relation_connectives}.
\federeboks{c}{
        \infeshort{Negation}
        {[\hat{a}] \nvDash \phi}
        {[\hat{a}] |= \neg \phi}
    \\\\
    \infeshort{Conjunction}
        {[\hat{a}] |= \phi_1 \quad [\hat{a}] |= \phi_2}
        {[\hat{a}] |= \phi_1 \wedge \phi_2}
    \\\\
    \infeshort{Disjunction-1}
        {[\hat{a}] |= \phi_1}
        {[\hat{a}] |= \phi_1 \vee \phi_2}
    \\\\
    \infeshort{Disjunction-2}
        {[\hat{a}] |= \phi_2}
        {[\hat{a}] |= \phi_1 \vee \phi_2}
}{\caption{Satisfaction relation for propositional connectives}\label{fig:satisfaction_relation_connectives}}

The general form of the satisfaction rules for the modalities $@o$, $\Diamond o$ and $\square o$ are defined in \cref{fig:satisfaction_relation_modal}. 
\federeboks{c}{
    \infeshort{At-op}
        {}
        {[o(\Vec{x_1}.\hat{a}_1; \dots; \Vec{x_n}.\hat{a}_n)] |= @o }  
    \\\\
    \infeshort{Necessity}
        {[\hat{a}_1] |= \Diamond o \ \dots \ [\hat{a}_n] |= \Diamond o}
        {[o(\Vec{x_1}.\hat{a}_1; \dots; \Vec{x_n}.\hat{a}_n)] |=\square o}
    
    \\\\
    \infeshort{Possibly-i}
        {[\hat{a}_i] |= \Diamond o}
        {[o(\Vec{x_1}.\hat{a}_1; \dots; \Vec{x_i}.\hat{a}_i; \dots; \Vec{x_n}.\hat{a}_n)] |= \Diamond o}
    \\\\
    \infeshort{Possibly-trivial}
        {[\hat{a}] |= @o}
        {[\hat{a}] |= \Diamond o}
}{\caption{Satisfaction relation for modal operators}\label{fig:satisfaction_relation_modal}}
The modality $@o$ holds for an abt $a$ if the cursor is at the root of
$a$ and the root is the operator $o$. 

The modality $\Diamond o$ is satisfied for $a$ when the operator $o$ is
anywhere within $a$. The modality
$\square o$ holds for $a$ when $o$ is found in every subtree of the
abt encapsulated by the cursor. 

% \begin{example}\label{ex:modal_logic}
%     We finalize our specialized editor calculus from \cref{ex:substitution_rules}, by defining the satisfaction relation. The propositional connectives are defined as previously shown in \cref{fig:satisfaction_relation_connectives}. In \cref{fig:example_satisfaction_relation} we have shown the satisfaction rules for all modalities for the $plus$ operator. Rules for the remaining operators $o$ are defined accordingly.
%     \federeboks{c}{
%         \infeshort{At-plus}
%             {}
%             {[\text{plus}(\hat{a}_1;\hat{a}_2)]|= @\text{plus} }  
%         \\\\
%         \infeshort{Pos1-plus}
%             {[\hat{a}_1] |= \Diamond o}
%             {[\text{plus}(\hat{a}_1; \hat{a}_2)] |= \Diamond o}
%         \\\\
%         \infeshort{Nec-plus}
%             {[\hat{a}_1] |= \Diamond o \quad [\hat{a}_2] |= \Diamond o}
%             {[\text{plus}(\hat{a}_1;\hat{a}_2)] |=\square o}
%         \\\\
%         \infeshort{Pos2-plus}
%             {[\hat{a}_2] |= \Diamond o}
%             {[\text{plus}(\hat{a}_1; \hat{a}_2)] |= \Diamond o}
%     }{\caption{Satisfaction relation for modal operators on $plus$}\label{fig:example_satisfaction_relation}}
% \end{example}

\subsection{Guarantees from the original editor calculus}

The original editor calculus of \cite{type_safe_structure_editor} is equipped
with a type system that types configurations relative to a path in the
ast of the configuration. Judgments are therefore of the form $p, \Gamma_e \vdash
\lr{E,a} : \textsf{ok}$, where $p$ is a path in the ast $a$ and
$\Gamma_e$ is a type environment.

The type system of the original calculus guarantees that a well-typed
configuration remains well-typed after a transition and that a
well-typed configuration will not get stuck. Here,
$(p,\Gamma_e)\downarrow_\alpha$ denotes that the path and the type
environment are updated because of the action $\alpha$. These
guarantees can be expressed as the following theorem.

\begin{theorem}[\cite{type_safe_structure_editor}]\label{thm:typesafe}
  If $p, \Gamma_e \vdash \lr{E,a} : \textsf{ok}$ then
  \begin{enumerate}
  \item if $\lr{E,a} \ltrans{\alpha} \lr{E',a'}$, then
    $(p,\Gamma_e)\downarrow_\alpha \vdash \lr{E',a'} : \textsf{ok}$
  
  \item $p, \Gamma_e \vdash \lr{E,a} \neg\to \textsf{wrong}$
  \end{enumerate}
\end{theorem}

\section{Encoding the generalized editor calculus} \label{sec:encoding}


\subsection{A collection of lambda calculi}

To encode the abstract binding trees, the simply typed lambda calculus
suffices, so for an $a \in \ABT{}$ we have $\encode{a} \in \stlc$.

In order to encode abts with cursors and expressions of the
generalized editor calculus, we extend \stlc with more constructs.

To represent contexts, we introduce pairs. To encode atomic prefix
commands we further extend the calculus with pattern matching
($\lambda_{->,p}$). Finally, to encode modal logic and editor
expressions recursion is needed in the form of the fixed point
operator ($\lambda_{->,p,fix}$).

An overview of the calculus and the constructs necessary to encode
each part of it can be seen in \cref{tab:encoding_requirements}.

\begin{table*}
   \centering
   \begin{tabular}{| l | l |}
       \hline
       \textsf{Editor calculus} & \textsf{Encoding}\\
       \hline\hline
       \ Abstract Binding Trees & \ Simply typed lambda calculus with pairs, \stlc \\
       \hline
       \ Atomic Prefix Commands & \ \stlc with pattern matching $\lambda_{->,p}$\\
       \hline
       \ Modal Logic & \ \stlc with pattern matching and recursion, $\lambda_{->,p,fix}$ \\
       \hline
       \ Editor Expressions & \ \stlc with pattern matching and recursion, $\lambda_{->,p,fix}$ \\
       \hline 
   \end{tabular}
   \vspace{1mm}
   \caption{Editor calculus fragments and the lambda calculus fragments
     used for encoding them}
   \label{tab:encoding_requirements}
 \end{table*}

 All of the lambda calculi that we consider have a
 standard reduction semantics with reductions of the form $e \to
 e'$.

 Moreover, every calculus has a type systems with type judgements of
 the form $\Gamma \vdash e : \tau$, where $\tau$ ranges over a set of
 types \Types\ given by
%
\[  \tau ::= \tau_s \mid \tau \to \tau \mid \tau \times \tau  \]
%
where $\tau_s$ is a type for each sort $s \in \mathcal{S}$ and $\tau
\to \tau$ and $\tau \times \tau$ are function and product types,
respectively, and $\Gamma$ is a type environment
 $\Gamma : \Var \pra \Types$. 

 The type systems all satisfy the subject
 reduction property.

 \begin{theorem}[Subject reduction]\label{thm:subred}
   If $\Gamma \vdash e : \tau$ and $e \to e'$, then $\Gamma \vdash e'
   : \tau$.
 \end{theorem}

 It is this result that ensures that our encoding will indeed provide
 a general result about type soundness for the generalized editor
 calculus.
 
\subsection{Abstract binding trees}

To encode abstract binding trees we only need to use the simply typed
lambda-calculus where we have term constants $o$ for every $o \in \OP$
excluding cursors, and the base types $s$ for every $s \in \SORT$.

Typing rules for operators can be seen on \cref{fig:abt_typing_rules},
where we can infer the type of an operator in the lambda-calculus by
its arity.  
\federeboks{C}{
    \infeshort{T-Operator}
        {o \in \OP \text{ and has arity } (\Vec{s_1}.s_1, \dots, \Vec{s_n}.s_n)s}
        {\Gamma |- o : (\Vec{s_1} -> s_1) -> \dots (\Vec{s_n} -> s_n) -> s}
}{
    \caption{Typing rules for operators.}
    \label{fig:abt_typing_rules}
}

With the operators added as term constants and sorts added as base
types, encoding abts is straightforward as we just have to curry the
operator $o$, encode the children $a_1, \dots, a_n$ and add
typings. This can be seen on \cref{fig:enc_abt}. 

\federeboks{C}{
    \encode{o(\Vec{x_1}.a_1, \dots , \Vec{x_n}.a_n)} = o \ (\lambda \Vec{x_1} : \Vec{s_1}.\encode{a_1}) \dots (\lambda \Vec{x_n} : \Vec{s_n}.\encode{a_n})
}{
    \caption{Encoding of abstract binding trees.}
    \label{fig:enc_abt}
}

\begin{example}\label{ex:enc_abt_example}
    We can now encode the operators in our small language. Following
    our singular rule for encoding abt's we get the resulting encoding
    seen on \cref{fig:enc_abt_example}, and the type for each operator
    on \cref{fig:abt_example_type}. 
    
    \federeboks{C C}{
        \encode{\text{plus}(a_1; a_2)} = \text{plus} \encode{a_1} \encode{a_2} 
        &
        \encode{\text{num}[n]} = \text{num}[n]
        \\\\
        \encode{\text{var}[x]} = \text{var}[x]
        &
        \encode{\text{hole}_e} = \text{hole}_e
        \\\\
        \encode{\text{exp}(a_1)} = \text{exp} \encode{a_1}
        &
        \encode{\text{hole}_s} = \text{hole}_s
        \\\\
        \multicolumn{2}{C}{
            \encode{\text{let}(a_1; x.a_2)} = \text{let} \ (\encode{a_1}) (\lambda x : e. \encode{a_2})
        }
    }{
        \caption{Encoding of operators.}
        \label{fig:enc_abt_example}
    }
    
    \federeboks{C C}{
        \text{plus} : e \to e \to e
        &
        \text{num}[n] : e
        \\\\
        \text{var}[x] : e
        &
        \text{hole}_e : e
        \\\\
        \text{exp} : e \to s
        &
        \text{hole}_s : s
        \\\\
        \multicolumn{2}{C}{
            \text{let} : e \to (e \to s) \to s
        }
    }{
        \caption{Types of the encoded operators.}
        \label{fig:abt_example_type}
    }
    
\end{example}

for example, if we were to encode the statement:
\begin{equation*}
        \text{let $x=[\hole{e}]$ in $x+5$}
    \end{equation*}
    it could be encoded as:
    \begin{align*} 
        \text{let} \ (\text{cursor}_e(\text{hole}_e)) \ (\lambda x . \text{plus} \ \text{var}[x] \ \text{num}[5])
  \end{align*}




\subsection{Cursor contexts}\label{sec:enc_cursor_contexts}

To represent abts with cursor contexts we introduce the pair construct similarly to \cite{types_programming_languages}.
%In \cref{fig:abt_cursor_syntactic_forms} we introduce the new syntactic forms which include the pair construct, first projection, second projection and the product type. 
%\federeboks{R C L l}{
%    \multicolumn{4}{c}{Terms}
%    \\
%    M & ::= &(M_1,M_2) & (pair) \\
%      & |   & M.1      & (first projection) \\
%      & |   & M.2      & (second projection)
%    \\\\
%    \multicolumn{4}{c}{Types}
%    \\
%    \tau & ::= & \tau_1 \times \tau_2 & (product type)
%}{\caption{Abstract syntax for representing cursor contexts as pairs.}\label{fig:abt_cursor_syntactic_forms}}


In \cref{fig:enc_abt_cursor} the encoding for cursor contexts can be seen. We can encode a cursor context $C[a]$ as a pair of two encoded trees the first being a regular abt and the second being an abt with a context hole $\ctxhole$, which we encode as an operator $\ctxhole$. We also introduce a type alias such that $\encode{C[a]}$ has type $Ctx = s \times s$.
\federeboks{C}{
    \encode{C[a]} = (\encode{a}, \encode{C}) \\
    \encode{\ctxhole} = \ctxhole
}{
    \caption{Encoding of cursor contexts.}
    \label{fig:enc_abt_cursor}
}

%\begin{example}
%    In \cref{ex:well_formed_trees} we saw that the expression.
%    \begin{equation*}
%        \text{let $x=[\hole{e}]$ in $x+5$}
%    \end{equation*}
%    is well-formed since it can be written as $C[\dot{e}]$ where
 %   \begin{align*}
 %       C &= \quad \text{let $x=\ctxhole$ in $x+5$} \\
  %      \dot{e}&= \quad [\hole{e}]
  %  \end{align*}
%    Encoding $C[\dot{e}]$ following the rules for encoding contexts and the rules for encoding abts in \cref{ex:enc_abt_example} yields the following encoding:
%    \begin{align*}
 %       & \encode{C[\dot{e}]} = \\ 
 %       & (\encode{\text{cursor}_e(\text{hole}_e)}, \encode{\text{let}([\cdot]; x.\text{plus}(\text{var}[x], \text{num}[5]))}) = \\ 
 %       & (\text{cursor}_e(\text{hole}_e), \text{let} \ [\cdot] \ (\lambda x . %\text{plus} \ \text{var}[x] \ \text{num}[5]))
 %   \end{align*}
    
%\end{example}

\subsection{Atomic prefix commands}

To encode the atomic prefix commands we further extend the lambda
calculus with pattern matching. The formation rules are extended as
shown below; $p$ is the metavariable for patterns.
% As seen in
% \cref{fig:apc_syntactic_forms} we introduce the match construct where
% we match the term $M$ on the patterns $p$ resulting in the
% corresponding term $N$ if there is a match. As mentioned $p$ is the
% syntactic category describing the pattern we are trying to
% match. These patterns consist of variables, wildcards, operators,
% pairs, and lastly bindings which recursively match on the body of an
% abstraction.  
% \federeboks{R C L l}{
%     \multicolumn{4}{c}{Terms}
%     \\
\begin{align*}
    M, N & ::= & \text{match}\ M\ \overrightarrow{p \to N} && \text{(match construct)}
    \\
    p & ::= & x              & & \text{(variable)} \\
      & |   & \_             && \text{(wildcard)} \\
      & |   & o\ \Vec{p}     && \text{(operator)} \\
      & |   & (p_1, p_2)     && \text{(pair)} \\
         & |   & .p             && \text{(binding)}
\end{align*}
%} {\caption{Abstract syntax for representing atomic prefix commands, extending the lambda-calculus with a match construct.}\label{fig:apc_syntactic_forms}}
%The reduction rules for the match construct can be seen in the full version of the paper.
%
We are now able to define functions functions that describe navigation
in an abt and substitution; the definitions are givren in
\cref{tab:zip_oper}. We introduce the abbreviation $[a]$ to mean the
cursor operator with the child $a$.

\federeboks{L}{
    \textit{down} \define \lambda x:s.\text{match }x
    \quad [o \ (.a_1) \dots (.a_n)] \to \\
    \quad o \ (\lambda \Vec{x_1}.[a_1]) \dots (\Vec{x_n}.a_n) \\\\

    \textit{right} \define \lambda x:s.\text{match }x
    \quad o \ (.a_1) \ \dots (.[a_i]) \ \dots (.a_n) \to \\
    \quad o \ (\lambda \Vec{x_1}.a_1) \ \dots (\lambda \Vec{x_{i+1}}.[a_{i+1}]) \ \dots (\Vec{x_n}.a_n) \\\\

    \textit{up} \define \lambda x:s.\text{match }x
    \quad o \ (.a_1) \dots (.[a_i]) \dots (.a_n) \to \\
    \quad [o \ (\lambda \Vec{x_1}.a_1) \dots (\lambda \Vec{x_n}.a_n)] \\\\
     
    \textit{set} \define \lambda a:s.\lambda x:s.\text{match }x
    \quad [a'] \to [a]
}{\caption{Defining cursor movement and
    substitution.}\label{tab:zip_oper}}

The encoding of atomic prefix commands are given in
\cref{fig:atc_enc}. Note that the $child$ command is defined
recursively. \textit{parent} and \textit{insert} are simply encoded as \textit{up} and \textit{set} respectively.
\federeboks{L L}{
    \encode{\textit{child} \ 1} = \textit{down}
    &
    \encode{\textit{child} \ n} = \textit{right}\ \encode{\text{child} \ n - 1}
    \\\\
    \encode{\textit{parent}} = \textit{up}
    &
    \encode{\textit{insert} \ a} = \textit{set} \ \encode{a}
}{
    \caption{Encoding of atomic prefix commands.}
    \label{fig:atc_enc}
}

\subsection{Control structures and modal logic}

To encode control structures and modal logic, we need to further
extend the lambda-calculus with a \fix operator as well as the $Bool$
base type. We introduce the \fix operator as seen in
\cite{types_programming_languages}, as well as boolean types and
values.

\cref{fig:edt_enc} shows the encoding of editor expressions. For
atomic prefixes the atomic prefix command is applied before the
rest of the editor expression. The $nil$ editor expression is
the identity function. Sequential editor expressions apply the
encoding of the editor expressions in the correct order. Recursion
works by using the \fix operator. Lastly, conditional
editor expressions are encoded such that we match on the evaluation of
$\phi$ on the first projection of a context $C$ and apply the encoding
of $E_1$ or $E_2$ on $C$ accordingly. 
%\federeboks{R C L l}{
%    \multicolumn{4}{c}{Terms}
%    \\
%    M & ::= & \fix\ M & (fixed point of M) \\
%      & |   & \top    & (true) \\
%      & |   & \bot    & (false)
%    \\\\
%    p & ::= & \top & (match true) \\
%      & |   & \bot & (match false)
%    \\\\
%    \multicolumn{4}{c}{Types}
%    \\
%    \tau & ::= & \text{Bool} & (boolean)
%}{\caption{Abstract syntax for control structures and modal logic, extending the calculus with the \fix operator and boolean types and term constants.}\label{fig:control_syntactic_forms}}


%In \cref{fig:cond_aux} we define auxiliary functions that will help with the encoding of conditional expressions. The auxiliary functions $and$, $or$ and $neg$ function as their name would suggest. In our semantics, when checking if a formula $\phi$ holds, we do so against an abt $a$ (i.e $a \vDash \phi$). When constructing the proof tree for such a formula we see that this abt $a$ is propagated up through the proof tree, thus we need to have the ability to propagate an abt throughout our encoded formula as well. To propagate this abt through $and$, $or$ and $neg$ we define the combinators $phoenix$ (liftA2/liftM2 in Haskell) and $bluebird$ (function composition / B combinator).  


\federeboks{C C}{
    \encode{\pi.E} = \lambda C:\text{Ctx}.\encode{E} ( (\encode{\pi} \ C.1) \ , C.2) 
    \\[2mm]
    \encode{E_1 \ggg E_2}  = \lambda C:\text{Ctx}. \encode{E_2} (\encode{E_1} C)
    \\[2mm]
    \encode{\text{rec } x.E} = \text{fix } ( \lambda x: (\text{Ctx} \to \text{Ctx}).\encode{E}) 
    \\[2mm]
    \encode{\phi => E_1 | E_2} = \lambda C:\text{Ctx}.\text{match} \ (\encode{\phi} \ C.1) \\
        | \ \top ->  \encode{E_1} \ C 
    \\[2mm]
    | \  \bot ->  \encode{E_2} \ C 
    \\[2mm]
    \encode{\text{nil}} = \lambda C:\text{Ctx}.C \quad \quad    \encode{x} = x

}{
    \caption{Encoding editor expressions}
    \label{fig:edt_enc}
}

\iffalse
\federeboks{L C L}{
    \text{phoenix} &\define& \lambda f: (\text{Bool} \to \text{Bool} \to \text{Bool}). \\
            &       & \lambda g: (s \to \text{Bool}). \\
            &       & \lambda h: (s \to \text{Bool}) . \\
            &       & \lambda a:s . \\
            &       & f (g a) (h a) 
    \\\\
    \text{bluebird} &\define& \lambda f: (\text{Bool} \to \text{Bool}). \\
             &       & \lambda g: (s \to \text{Bool}) . \\
             &       & a:s . \\
             &       & f (g a)
    \\\\

    \iffalse
    \text{and} &\define& \lambda \phi_1:(s -> \text{Bool}). \lambda \phi_2:(s -> \text{Bool}) .\lambda a:s.\text{match} (\phi_1 \ a, \phi_2 \ a) \\&&(\top, \top) -> \top \\&|& (\_,\_) -> \bot 
    \\\\

    \text{or} &\define& \lambda \phi_1:(s -> \text{Bool}). \lambda \phi_2:(s -> \text{Bool}) .\lambda a:s.\text{match} (\phi_1 \ a, \phi_2 \ a)\\&& (\bot, \bot) -> \bot \\&|& (\_,\_) -> \top
    \\\\

    \text{neg} &\define& \lambda \phi:(s -> \text{Bool}).\lambda a:s.\text{match} (\phi \ a) \\
    &|& \top -> \bot \\
    &|& \bot -> \top
    \\\\
    \fi
    
    \text{or} &\define& \lambda b_1:\text{Bool}. \lambda b_2:\text{Bool}.\text{match} \  (b1,b2) \ \\
    &|& (\bot,\bot) -> \bot \\
    &|& (\_, \_) -> \top)
    \\\\
    
    \text{and} &\define& \lambda b_1:\text{Bool}. \lambda b_2:\text{Bool}.\text{match} \  (b1,b2) \\
    &|& (\top,\top) -> \top \\
    &|& (\_, \_) -> \bot)
    \\\\

    \text{neg} &\define& \lambda b:\text{Bool} . \text{match } b \\
        & |     & \top \to \bot \\
        & |     & \bot \to \top
}{
    \caption{Function definitions for auxiliary functions.}
    \label{fig:cond_aux}
}
The encoding of propositional connectives is shown in
\cref{fig:encoding_connectives}.

\federeboks{L}{
    \encode{\phi_1 \wedge \phi_2 } = \text{phoenix and} \ \encode{\phi_1} \ \encode{\phi_2}
    \\\\
    
    \encode{\phi_1 \vee \phi_2} = \text{phoenix or} \ \encode{\phi_1} \ \encode{\phi_2}
    \\\\
 
    \encode{\neg \phi} = \text{bluebird neg} \ \encode{\phi}
    \\\\
    \encode{@o} = \lambda x:s . \text{match } x \\
                \quad | \ [o \ \_ \ \dots \ \_] \to \top  \\
                \quad | \ \_ \to \bot
}{\caption{Encoding of propositional connectives}\label{fig:encoding_connectives}}
In \cref{fig:cond_enc} we show the encoding of modal logic operators.
\federeboks{L}{    
    \encode{\Diamond o} = \text{\fix} (\lambda f:(s->\text{Bool})
    . \lambda x:s . \text{match } x \\
                        \quad | \ [o \ \_ \ \dots \ \_] \to \top \\
                        \quad | \  [\_(\_.a_1 , \dots ,\_.a_n)] \to \\
                        \quad\ \ \text{or} ( \dots (\text{or}\ (f\ [a_1]) \ (f \ [a_2]))\ \dots ) \ (f\ [a_n])\\
                        \quad | \ \_ \to \bot )
    \\\\
    \encode{\square o_1} = \lambda x:s . \text{match } x \\
                         \quad | \ \_(\_.a_1 , \dots ,\_.a_n) \to \\
                         \quad\ \ \text{and}(\dots (\text{and}  (\encode{\Diamond o}\ a_1) (\encode{\Diamond o} \ a_2)) \dots )\ (\encode{\Diamond o} \ a_n) \\
                         \quad | \ \_ \to \top
}{
    \caption{Encoding of modal logic and boolean logic operators.}
    \label{fig:cond_enc}
}
$@o$ is encoded such that we pattern match on the on the operator $o$, and if there is a match the resulting value is true, otherwise it is false. $\Diamond o$ uses the \fix operator, as the function is recursively defined. 
$\square o$ consists of either applying $\Diamond o$ on all the children of the tree, or returning true if there are no children.
\fi


% \begin{example}
%     We are now able to give an example of how to encode editor
%     expressions. Consider
%     \begin{equation*}
%         \text{child\ $2$.nil $\ggg$ parent.nil}
%     \end{equation*}
%     using the encoding rules seen on \cref{fig:edt_enc} and \cref{fig:atc_enc}. For readability purposes we will not add explicit typings, just note that any variable $C_i$ has type $Ctx$.
%     \begin{align*}
%          &\ \encode{\text{child\ $2$.nil $\ggg$ parent.nil}} \\
%          =&\ \lambda C_1 . \encode{\text{parent.nil}} (\encode{\text{child\ $2$.nil}} C_1) \\
%          =&\ \lambda C_1 . (\lambda C_2 . \encode{\text{nil}}(\encode{\text{parent}} C_2.1, C_2.2)) (\encode{\text{child\ $2$.nil}} C_1) \\
%          =&\ \lambda C_1 . (\lambda C_2 . \encode{nil}(up\ C_2.1, C_2.2)) (\encode{child\ 2.nil} C_1) \\
%          =&\ \lambda C_1 . (\lambda C_2 . (\lambda C_3 . C_3)(up\ C_2.1, C_2.2)) (\encode{child\ 2.nil} C_1) \\
%          \betar&\ \lambda C_1 . (\lambda C_2 . (up\ C_2.1, C_2.2)) (\encode{child\ 2.nil} C_1) \\
%          =&\ \lambda C_1 . (\lambda C_2 . (up\ C_2.1, C_2.2)) (\lambda C_3 . \encode{nil} (\encode{child\ 2} C_3.1, C_3.2)C_1) \\
%          =&\ \lambda C_1 . (\lambda C_2 . (up\ C_2.1, C_2.2)) (\lambda C_3 . (\lambda C_4.C_4) (\encode{child\ 2} C_3.1, C_3.2)C_1) \\
%          \betar&\ \lambda C_1 . (\lambda C_2 . (up\ C_2.1, C_2.2)) (\lambda C_3 . (\encode{child\ 2} C_3.1, C_3.2)C_1) \\
%          =&\ \lambda C_1 . (\lambda C_2 . (up\ C_2.1, C_2.2)) (\lambda C_3 . right (\encode{child\ 1} (C_3.1, C_3.2))C_1) \\
%          =&\ \lambda C_1 . (\lambda C_2 . (up\ C_2.1, C_2.2)) (\lambda C_3 . right (down (C_3.1, C_3.2))C_1) \\
%     \end{align*}
%     As can be seen, the editor expression could be fully encoded to the extended lambda calculus. We refer to the full paper for
% \end{example}

\subsection{Encoding configurations}

It is now straightforward to encode configurations as follows.
%
\[ \encode{\lr{E, C[a]}} = \encode{E} \  (\encode{a}, \encode{C}) \]
%
Note that here $\encode{E} : T \times T_C \to T$ where $T$ is the type
of the encoding of an abt and $T_C$ is the type of the encoding of a context.

\section{Soundness of the encoding}

The main result about our encoding is that it is sound wrt. the
operational semantics of the original calculus.

\begin{theorem}[Soundness] For every editor expression $E$ and abt $a$
  we have that if
  %
  \[ \lr{E,a} \ltrans{} \lr{E',a'} \]
  then
  \[ \encode{E}\encode{a} \rightarrow^{\ast}  \encode{E'}\encode{a'}  \]
\end{theorem}

Because of Theorem \ref{thm:subred}, we now get that our encoding is
type-safe.

\begin{corollary}
  If $\Gamma \vdash \encode{\lr{E,C[a]}} : t$ then, if $\lr{E,a}
  \ltrans{} \lr{E',a'}$, we also have $\Gamma \vdash \encode{\lr{E',C[a']}} : t$.
\end{corollary}

\section{Conclusion and Further Work}

We have developed a generalized editor calculus that enables the
creation of a syntax-directed editor calculus for a specific abstract
syntax, and describe how to encode it into a monomorphic typed lambda
calculus with pairs, recursion and pattern matching. The encoding is
sound, and as a consequence, given that the type system of the
extended lambda calculus is sound, it follows that our editor calculus
is typesafe.

Further work on our generalized editor calculus is to prove whether
the encoding is complete.  An important next step is to incorporate a
copy-paste operation. Here, the question arises as to how to best deal
with pasting terms that include free variables. In some settings, when
editing code, this will introduce name clashes, but in other settings
the free variables should intentionally be captured. A likely solution
is therefore to have two different paste operations corresponding to
each of these situations.

\bibliographystyle{ACM-Reference-Format}
\bibliography{bibliography}


\end{document}
\endinput

%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
